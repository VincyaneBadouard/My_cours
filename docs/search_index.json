[["index.html", "My cours My personal courses Preface", " My cours My personal courses Vincyane Badouard 2022-01-26 Preface This book contains my personal courses. Some are in French, some in English, or bothsorry. Have a nice reading. Vincyane "],["introduction.html", "Introduction", " Introduction Blah. "],["fonctions-bien-sympatiques-trés-cher.html", "Cours 1 Fonctions bien sympatiques trés cher 1.1 Conseils 1.2 Tips de codeur 1.3 Charger les données 1.4 Corection préliminaires des données 1.5 Transformation de données ! 1.6 Histoire de characters 1.7 La syntaxe qui fait chier, du balai ! 1.8 Comparaison de tables 1.9 Tirage 1.10 Yo ! arrange mes données ! 1.11 Donne moi des infos sur mes données 1.12 Calcul informatif 1.13 sf package 1.14 Eh oh cest moi qui décide ! illustre moi ça comme il faut ! 1.15 Télécharger mon bébé dans le bon format, au bon endroit ! 1.16 Nettoyage 1.17 Boucle 1.18 Les objets 1.19 Condition 1.20 Logical Operators 1.21 Stan - Modelo - Bayes 1.22 Faire de la biblio comme une déesse 1.23 Date &amp; time", " Cours 1 Fonctions bien sympatiques trés cher ICI JE METS JUSTE LE NOM DES FONCTIONS, MAIS FAUT CHERCHER SUR INTERNET LES MODALITES DUTILISATION !! 1.1 Conseils Eviter de donner le meme nom au pipe que la base quon utilise dedans, ça écrase les données, et cest la galere pour les reccuperer Les fonctions tidy sont pas faites pour simbriquer. Utiliser des fonctions base à lint des fcts tidy. Qd un prblm est trop gros, découper le travail (ex: faire des soustables) 1.2 Tips de codeur Mesurer le temps dexécution dun code : system.time ou microbenchmark (fct1,fct2) pour des codes trés courts. Ce sont les médianes des temps de calcul quil faut comparer. détacher un package de lenvironnement : unloadNamespace() connaitre le code dune fct : trace(pkgname::fct, edit=T) tout bien aligner le code : ctrl A puis ctrl I recherche sur toutes les pages : Ctrl shift F (on peut faire du replace !) (obt &lt;- code) : affiche lobjet 1.3 Charger les données Chemin absolu : écriture de lentièreté du chemin Chemin relatif : ~ = le dossier du setwd ./ = là où je suis Les .rmd ont leur propre racine, donc pas celle de leur projet. « ../ = dossier parent (du niv de dessus) et je mets autant de ../ que de niveau à remonter. Puis tabulation pour quil propose mes fichiers. Stocker mon chemin relatif dans un objet « path ». file.path(path, dossier, file) function pour lire mon chemin stocké. !!!!!!Environment &gt; import dataset &gt; tjrs spécifier le séparateur (delimiter) et le marqueur de décimale (locale &gt; decimal mark)!!!!!!!!! (franchement ça fait trop de la m**rd sinon) Importer avec les accents : locale = locale(encoding = latin1) Importer du shapefile (shp) : readORG(dsn = /path/to/your/file, layer = filename) ou shapefile(path/to/your/file.shp) 1.4 Corection préliminaires des données Corriger les arbres non touvées mais vivants dans inventaires : package forestdata sur github ecofog 1.5 Transformation de données ! De character à factor : mutate(Vernacular = factor(as.character(Vernacular))) Séparer 1 colonne en plsrs : **separate(data, col à séparer, sep = \"_\", into = c(nom des new col), remove = F)** remove = F pour conserver la colonne quon sépare Combiner des colonnes en une : unite(col1, col2, col = sp, sep = \" \", remove = T) La même qd ya pas de séparateur : mutate(variable = substr(x, start, stop)) ou StrLeft(x, n) StrRight(x, n) en partant de la fin. -n pour enlever n paramètre Recoder une variable : mutate(var = recode(var, 1 = A , 2 = B)) le nouveau code derière le = si ya erreur essayer : 1 = A ; 2 = B guillemets double et simple et point virgule Changer une variable sous condition : mutate(var = ifelse(condition, si oui, sinon)) Sous plusieurs conditions : séparer les conditions dun &amp; Changer le nombre de décimales : format(x, digits = 0, scientific = F) ou round(x, digits = 0) effectuer par ligne : rowise Remplir une colonne à partir dune fonction dont linput est une table : do() déplie la une sous-table existant dans une table : unnest() 1.6 Histoire de characters Extraire un element numeric dans une chaîne de characters : extract_numeric(var) Mettre le nom dun objet sous forme de chararters : deparse(substitute(obj)) 1.7 La syntaxe qui fait chier, du balai ! Enlever un espace avant et/ou apres un character : trimws(x, which = c(both, left, right)) Mettre en minuscule/majuscule : tolower()/toupper() 1ère lettre de lexpression en majuscule : str_to_sentence() Enlever accent : sub(é,e,vector)) 1.8 Comparaison de tables diffdf(,) 1.9 Tirage Tirer aléatoirement n individus sans remplacement : sample_n(n, replace = F) 1.10 Yo ! arrange mes données ! Vincyane la base ## Quand tu veux passer une collone de df en argument de fonction : ## V0 column_name &lt;- &quot;Position&quot; ## character string in an object column &lt;- inventory[,column_name] ## character vector line_nonna &lt;- which(!is.na(column)) ## which rows different of NA subinventory &lt;- inventory[line_nonna,] ## filter base version ## V1 column_name &lt;- &quot;Position&quot; column &lt;- inventory[,column_name] nonna &lt;- !is.na(column) ## logical vector subinventory &lt;- inventory[nonna,] ## take only the TRUE ## V2 column_name &lt;- &quot;Position&quot; inventory[!is.na(inventory[,column_name]),] %&gt;% st_as_sf(wkt = column_name) ## Vdplyr col_name &lt;- deparse(substitute(var)) ## object name to this name in character inventory %&gt;% filter(!is.na( {{ var }} )) %&gt;% ## {{var}} pour réccupérer l&#39;objet mis en argument &quot;var&quot; st_as_sf(wkt = col_name) ## quand t&#39;as besoin du nom de la colonne en charactère #ou modif_var &lt;- function(data, nom_variable){ data %&gt;% dplyr::mutate(nouveau_nom = !!rlang::sym(nom_variable)+1) } Inverser lignes &amp; colonnes (retourner) (transposer) : t() Mettre une colonne en colonne rownames : column_to_rownames(data, varàdéplacer) Metrre linformation de plusieurs colonnes en 1 : melt() Inverse : dcast(col1 + col2 ~ newcol) Ne prendre quune partie des données : filter() ou subset() Si on veut garder les NA, comme filter les vire doffice, rajouter | is.na(var) Pour filtrer beaucoup de valeurs dune même var: values &lt;- c(Tom, Lynn) vecteur de nimporte quoi filter(dat, var %in% values) Ne pas prendre une partie des données (valeurs) : filter(!(Vernacular %in% remove)) (enlever remove dans vernacular) Quand dans un booléen les Na dérangent, utiliser plutot %in% que == (ex: a %in% TRUE) Enlever des colonnes : select(-colname) Réaliser les opérations suivantes par groupes de modalités : group_by Créer une variable résumant les effectifs des éléments dune variable : summarise(N = n()) ou count() Effectifs par ordre croissant : arrange(N) Effectifs par ordre décroissant : arrange(desc(N)) Ranger par ordre alphabétique : dabord transformer la variable character en factor, puis arrange(var) Selectionner les n valeurs maximales : top_n Afficher les 30 1ères lignes : slice(1:30) Changer ordre des colonnes : select(c(a, y, x, b : w)) Séparer une base de données, selon un facteur, en une liste de bases de données : split(data, data$fact) Enlever les lignes en plusieurs exemplaires/connaitre les valeurs que peut prendre une colonnne : unique() Savoir si ttes les valeurs dune colonne sont les mêmes: length(unique(data\\(var)) == 1** ou **all(data\\)var == data$var[1]) = est-ce que toutes les valeurs sont égales à la 1ère 1.11 Donne moi des infos sur mes données pH[pH&gt;7] : afficher les ph&gt;7 length(pH[pH&gt;7]) : combien de ph&gt;7 data[pH&gt;7,] : afficher les lignes dont les ph&gt;7 which(x==a) : renvoie les indices (n°de lignes) de x pour lesquels le résultat de lopération logique est vrai Indicer selon une modalité : data[data$var ==modalite,] Nombre de NA dans 1 colonne : sum(is.na(data$x_num)) Nombre de lignes ayant pour valeur truc dans telle variable sum(as.numeric(data$var == truc), na.rm = TRUE) pcq as.numeric transforme un vecteur de booléen en vecteur de 0 et 1. Nombre de NA dans le jeu de de données, dans chaque colonne : colSums(is.na(data)) est-ce que tt ça est vrai : all() au moins 1 vrai : any() ne prend pas de liste (enfin si mais il nest pas cntent)! renvoyer les éléments dupliqué : duplicated() (booléen) y_data[!duplicated(my_data$var), ] (dataframe) anyDuplicated 1.12 Calcul informatif Faire la somme/moyenne/autre de chaque ligne/colonne : apply(data, c(1,2), sum) 1 : par ligne ou 2 : par colonne Appliquer une fonction sur une liste/vecteur : lapply(liste, function(elementdelaliste) la fonction dépendante de lélement) ou lapply(liste, function, autres arguments de la fct) ex : lapply(a, function(element) bcDiversity(element$N, q = 1, Correction = &quot;Best&quot;)) ptit tips : la version fonction dextraction délément dun objet ($) : getElement(object, var) ex : lapply(x, function(x) x$var) = lapply(x, function(x) getElement(x, &quot;var&quot;)) = lapply(x, getElement, &quot;var&quot;) Appliquer une fonction sur plsrs listes/vecteurs : mapply(function(X,Y) {la fonction(X, Y)}, X=list1, Y=list2, SIMPLIFY = F) SIMPLIFY = F : laisse la structure initiale de la liste map functions family font apriori la même chose que les apply avec plus de possiblités et + rapides car écrites en C (https://r4ds.had.co.nz/iteration.html) Les map ne produisent que des vecteurs, pas de matrice) Quand onotre map ne fctne pas il ne renvoie rien. Pour savoir ce quil ne va pas : map(safely(fct)) qui renvoie le résultat et le message derreur 1.13 sf package Passer dun sf à un dataframe (supprimer la col géométrie) : st_geometry(sf) &lt;- NULL sfg to sfc : st_sfc(sfg) sfc to sfg : st_point(as.numeric(unlist(sfc))) (ex ici point) MULTIPOINT to POINT : st_cast(st_sfc(mutipoint), POINT, group_or_split = TRUE) Simplification dobjet : st_cast(objet, objt + simple (ex : polygon to linestring) Attribuer un crs à un objt sf ou sfc : st_set_crs(objtsanscrs, st_crs(objtaveccrs)) st_union ne préserve pas lordre des géométries dans la géométrie finale, il faut utiliser : objt_sf_12 &lt;- objt_sf_1 %&gt;% rbind(objt_sf_2) objt_sf_12 &lt;- do.call(c, st_geometry(objt_sf_12)) 1.14 Eh oh cest moi qui décide ! illustre moi ça comme il faut ! Faire des graphs ggplot en clic bouton : esquisse::esquisser() Relier le label au point quuand cest pas visible : geom_text_repel Pour pouvoir faire un facet_wrap (plsrs graphs en 1 figure), il est plus aisé de transformer sa table de Wide-format à long-format (https://seananderson.ca/2013/10/19/reshape/): melt() Séparer un facet_wrap en plusieurs pages : facet_wrap_paginate() Echelles différentes sur un facet : scales = free free_x free_y or fixed qd on veut personnaliser : on crée un data pour un geom_blank : blank_data &lt;- data.frame(group = c(var1, var1, var2, var2), x = c(min commun, max commun, min commun, max commun), y = c(min commun, max commun, min commun, max commun)) puis geom_blank(data = blank_data, aes(x = x, y = y)) Gradient de couleurs : colorRampPalette(c(blue, white, red))(4) 4 = nbr de catégories ou scale_fill_gradient2(low=blue, high=red, mid = white) Voir les palettes : RColorBrewer::display.brewer.all() 1.15 Télécharger mon bébé dans le bon format, au bon endroit ! PNG : png() avant commande du plot &amp; dev.off() après commande du plot 1.16 Nettoyage Enlever un élément de lenvironement : remove() Vider tt lenvrmt global : rm(list = ls()) ls() renvoie ts les objets de lenvmt 1.17 Boucle Output : créer un objet vide de la classe, voire de la taille que lon souhaite pour notre output (+ rapide) chaine de charactère vide : \"\" vecteur/liste : vector(numeric, length(x)), ou juste vector(), list() Quand on ne connait pas la longeur de loutput apriori, on peut laggrandir progressivement dans le corps de la boucle : output &lt;- c(output, action quon boucle) ou on stocke les outputs de chaque itération dans un élément dune liste crée en amont (vector(list, length(x))), puis qd la loop est finie on unlist (+efficace). En résumé pour les gros outputs, il vaut mieux créer des outputs plus légers à chaque iteration puis tout coller ensemble après la boucle (-lourd). Sequence : créer un vecteur dans lequel puiser sil nexiste déjà pour agir sur chaque col dun df : seq_along(df) boucler sur indice, value ou names Body : Pour chaque valeur que peut prendre trait dans All_traits : for(trait in All_traits){} resultat &lt;- rep(NA, 3) for(i in seq_len(3)) { resultat[i] &lt;- i } utiliser [[]] plutot que [] même pour les vecteurs seq_along() : permet dans le cas où la sequence est de taille 0 ou 1 de bien avoir un output de cette taille sinon avec 1:length(1 ou 0) on optiendra 1 0 ou 1 1 faire une boucle dont les résultats sont mis dans une liste: foreach() Boucle while : boucle jusqà ce que la condition soit fausse. Peut être utilisée lorsquon ne connait pas la longueur de la séquence. while (condition) { ## body } Arrêter la boucle : break() Arreter litération actuelle et asser à la prochaine : next() 1.18 Les objets 1.18.0.1 des infos sur mon objet Présence dune variable varName %in% names(df) Type : class(a), pour ttes les variables dune table lapply(data, class) Structure : str(a, 1) 1 cest le niveau de structure, yen a plsrs, cest pas obligatoire 1.18.0.2 List a la liste. + Voir les éléments de la liste : a$ + Indicer une liste : a[[position]] Transposer une liste (inverser la tructure) : purr::transpose() 1.18.0.3 Fonction function(arguments){ operation1 operation2 return() ## préciser ce que la fonction doit renvoyer } 1.19 Condition Les if sont des booléens qui vérifient si la condition est TRUE, donc il nest pas nécessaire x == TRUE mais seulement x ou !x + if(condition) {action} + if(condition1 &amp;&amp; condition2) { expression } + if(condition1 || condition2) { expression } Dans les if else la place des brackets est importante: if(case1) { expression1 } else { expression2 } if(case1) { expression1 } else if(case2) { expression2 } ... else last.expression ifelse(condition, expression1, expression2) vectorized version of the if() statement. Warning: ifelse() is designed to work with vectors and matrices  not data frames. 1.20 Logical Operators c(T, F, T) | c(F, F, T) ## TRUE FALSE TRUE c(T, F, T) || c(F, F, T) ## TRUE c(F, F, T) || c(F, F, T) ## FALSE c(F, F, T) || c(T, F, T) ## TRUE ## |/&amp; to compare each value of different bolean vectors ## ||/&amp;&amp; to compare single value conditions 1.21 Stan - Modelo - Bayes Chercher une fct dans Rstan : lookup(bernoulli) 1.22 Faire de la biblio comme une déesse package bibliometrix 1.23 Date &amp; time convertir une date (y, m, d) en année numeric : as.numeric(format(ExactDate, %Y)) "],["datatable-functions.html", "Cours 2 datatable functions 2.1 Sources 2.2 Pourquoi data.table 2.3 Syntax 2.4 Create a data.table 2.5 Convert a data.frame or list to a data.table 2.6 Punctuation 2.7 Subset rows : 2.8 Extract columns : 2.9 Summarize 2.10 Compute columns 2.11 Change column class 2.12 Group 2.13 Common grouped operations 2.14 A sequence operation on a datatable 2.15 Functions ! 2.16 Combine data.tables 2.17 Indexation 2.18 Reshape 2.19 Avoir des infos/calculer des statistiques 2.20 Apply functions 2.21 Sequential rows 2.22 Maniement de chaines de caractères 2.23 Read and write files 2.24 Programmer des fonctions avec data.table", " Cours 2 datatable functions 2.1 Sources https://www.rdocumentation.org/packages/data.table/versions/1.14.2 (R doc) https://larmarange.github.io/analyse-R/manipulations-avancees-avec-data-table.html (French, trés bien!) https://linogaliana.netlify.app/post/datatable/datatable-intro/ (French, trop bien !!) https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html (vignette) https://stackoverflow.com/questions/tagged/data.table (stackoverflow) https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html (frequent questions in dt) 2.2 Pourquoi data.table https://dreamrs.github.io/talks/20180528_RAddicts_datatable.pdf data.table est particulièrement adapté aux données volumineuses (plus de 1Go) où lutilisation de dplyr est vivement déconseillée data.table est beaucoup plus rapide et puissant que dplyr ne dépend que de R-base, importe uniquement le package methods 2.3 Syntax dt[i, j, by] dt : data.table i : rows j : columns/expressions by : grouped columns ces 3 éléments ne sont pas toujours présents Les crochets permettent de ne pas utiliser le $. data.table also = to data.frame 2.4 Create a data.table library(data.table) dt &lt;- data.table(a = c(2, 1), b = c(&quot;a&quot;, &quot;b&quot;)) dt[, `:=`(c = 1 , d = 2, e = c(1, 2))] dt &lt;- dt[, -c(2)] ## remove b column (il faut assigner sinon il ne l&#39;enregistre pas) dt[, e := NULL] ## là non dt[, c, by = .(a)] dt[, c, keyby = .(a)] ## group and order 2.5 Convert a data.frame or list to a data.table setDT(df) (preferred) or as.data.table(df) setDF(dt) to return in data.frame 2.6 Punctuation les fonctions commençant par set ou contenant lopérateur := nont pas besoin dêtre réassigné à lobjet avec &lt;-. Cest mieux car ne garde pas de copie en mémoire. le . est un raccourci de list entre [ ] mais pas en dehors := ou :=() (assignation par référence) permet de modifier une variable en assignation directe, donc pas besoin de &lt;- -&gt; + rapide et très économe en mémoire vive 2.7 Subset rows : by rows positions : dt[1:2, ] by values in one or more columns : dt[a &gt; 5, ] ! ne renvoie pas les NA contrairement au data.frame ! La virgule nest pas obligatoire si pas de colonnes à spécifier. %like% %between% 2.8 Extract columns : Les colonnes sont des listes. by position : dt[, c(2)], prefix - to drop by names : dt[, .(b, c)] le point est un raccourci de list dans les [] pas en dehors. return as vector : dt[, b] ou dt[[b]] return as data.table : dt[, list(b)] On ne peut pas directement selctionner un var par sa position ou avec une chaine de charactères car compris comme des cstes 2.9 Summarize dt[, .(x = sum(a))] create a data.table with new columns based on the summarized values of rows. Summary functions ex : mean(), median(), min(), max(), etc .N pour obtenir le nombres dobservations ,by = par sous-groupe 2.10 Compute columns := permet de modifier une variable en assignation directe, donc pas besoin de &lt;-. () pour dire que ce sont des colonnes existantes et non des nouvelles a creer dt[, c := 1 + 2] : compute a column based on an expression (c = col name) dt[a == 1, c := 1 + 2] : compute a column based on an expression but only for a subset of rows Si on veut mettre des NA : := NA_real_ dt[, :=(c = 1 , d = 2)] : compute multiple columns based on separate expressions (se créent en meme temps donc ne peut pas dépendre de lautre) ou dt[ , c(newcol1, newcol2) := list(col1 ** 10, col2 ** 20)] Delete a column : dt[, c := NULL] (trés rapide) Séparer 1 col en 2 : dt[, c(cola, colb) := tstrsplit(col, \"_\", fixed = TRUE)] Unire 2 col en 1 : dt[, xy:= paste0(x,y)] ou dt[, xy:= paste(x,y, sep = \"_\")] 2.11 Change column class dt[, b := as.integer(b)] 2.12 Group dt[, j, by = colname] : by 1 var dt[, j, by = .(a)] : group rows by values in specified columns (a the column). dt[, j, by = c(var1, var2, var3)] dt[, j, keyby = .(a)] : group and simultaneously order rows by values in specified columns. 2.13 Common grouped operations dt[, .(c = sum(b)), by = a] : summarize rows within groups. dt[, c := sum(b), by = a] : create a new column and compute rows within groups. dt[, .SD[1], by = a] : extract first row of groups. dt[, .SD[.N], by = a] : extract last row of groups. dt[, .(new = old, new = col1 + col2)] : rename a col, and compute another 2.14 A sequence operation on a datatable Pour enchaîner les opérations : dt[][] Règle : pas faire de lignes trop longues et crochet de fin dop et celui de début de la prochaine doivent être accolé : ][ 2.15 Functions ! On peut y appliquer nimporte quelle fct de nimporte quel pkg, mais préférer celles du pkg data.table. Remove rows with missing values : na.omit(dt, cols=c(cols1, col2), invert=FALSE) cols et invert ne sont pas obligatoires Order columns values : setorder(dt, a, -b) - to decreasing order ou dt[order(a, -b)] Extract unique rows on specified col unique(dt, by = c(a, b)) no by to use all columns Count the nbr of unique rows : uniqueN(dt, by = c(a, b)) Rename col : setnames(dt, c(old1, old2), c(new1, new2)) ou dt[, .(new = old)] changer ordre des colonnes : setcolorder(DT, c(col1,col2)) avec := : dt[ , col_min := tolower(col)] 2.16 Combine data.tables Avec une fct : data.table::merge(x, y, [options]) (comme les join tidy, voir les options) Join on rows with equal values : dt_a[dt_b, on = .(b = y)] on pour spécifier les col équivalentes mais de noms différents on equal and unequal : dt_a[dt_b, on = .(b = y, c &gt; z)] Rolling join Combine rows of 2 datatables : rbind(dt_a, dt_b) Combine columns of 2 datatables : cbind(dt_a, dt_b) 2.17 Indexation Très puissant pour accélérer les opérations sur les lignes (filtres, jointures) Déclarer les variables faisant office de clef (key) : setkey(dt, a, b) ou setkeyv(dt, c(a,b)) ou setkey(dt, a) si qu1 var. -&gt; réordone selon cette clef Peut prendre bcp de temps (qqmin)mais gros gain de temps pour les opérations ultérieures. Pour savoir si un data.table est déjà indexé : key(dt) qui renvoie le nom des clés ou NULL. 2.18 Reshape https://rdatatable.gitlab.io/data.table/articles/datatable-reshape.html Long to wide format : dcast(dt, id ~ y, value.var = c(a, b), fun.aggregate = list(mean, sum)) with: y = col name in the longformat whose values will become the columns of the wide format value.var : col name whose values in columns will be put in rows (colonnes à transposer) fun.aggregate : si on veut utiliser des fcts pour aggrége les données Pour des noms plus significatifs des nouvelles colonnes : id ~ paste0(y, y) (préciser lappartenance à y à chaque nom de col) Conseil : Il faut donc faire attention à ce que ces variables aient un nombre limité de valeurs, pour ne pas obtenir une table extrêmement large. On peut éventuellement discrétiser les variables continues, ou regrouper les modalités avant dutiliser dcast() Wide to long format (ce quon veut!) : melt(dt, id.vars = c(&quot;id&quot;), measure.vars = patterns(&quot;^a&quot;, &quot;^b&quot;), variable.name = &quot;y&quot;, value.name = c(&quot;a&quot;, &quot;b&quot;)) with : id.vars : variables qui identifient les lignes de table darrivée; col qui restent des cols. measure.vars : cols to rows (variables qui sont transposées) variable.name : new col name for values in rows to this column (nom de la nouvelle colonne qui contient le nom des variables transposées) value.name : new col names (nom de la nouvelle colonne qui contient la valeur des variables transposées.) 2.19 Avoir des infos/calculer des statistiques dt[, sum(b)] : pour renvoyer la valeur Pour en calculer plsrs à la fois : dt[, .(mean = mean(b), sd = sd(b))] .N : nbr dobs uniqueN : nbr dobs uniques %in% : nbr dans la liste %chin% : character dans la liste %between% : valeur entre deux nombres %like% ^x : Reconnaissance dune chaîne de caractères rowid(var1, var2) : créer un identifiant de ligne unique pour un goupe de variables (= un compteur) 2.20 Apply functions dt[, lapply(.SD, mean), .SDcols = c(a, b)] (create a new table) dt[ , names(dt) := lapply(.SD, as.character)] for all the columns dt[, (cols) := lapply(.SD, as.character), .SDcols = cols] for specified columns (cols = c(a, b)) () pour dire que ce sont des colonnes existantes et non des nouvelles a creer dt[, paste0(cols, \"_m\") := lapply(.SD, mean), .SDcols = cols] add a suffix .SD : Subset of Data (= mot clef de data.table, représentant les colonnes) .SDcols : columns on which to apply 2.21 Sequential rows 2.22 Maniement de chaines de caractères séparer une colonne en fonction dun caractère : data.table::tstrsplit() 2.23 Read and write files Lecture et ecriture de fichiers plats (= fichiers texte) Import : fread(file.csv, select = c(a, b)) + Très rapide pour importer des gros volumes de données et nettement plus rapide que les fcts du pkg readr. + Permet de selectionner les colonnes quon veut ou ne veut pas importer + un grand nbr doptions Export : fwrite(dt, file.csv) 2.24 Programmer des fonctions avec data.table 2.24.1 Sécuriser Quand on utilise := on peut par erreur écraser des données. Donc la sécurité cest de faire une copie des input en entrée de fonction et travailler sur cette copie (qui porte un autre nom). 2.24.2 Variables en argument Pas necessaires si cest de la valeur en chaine de characteres dont on a besoin. Si on a besoin du symbol/name, ils nous faut ces outils : https://linogaliana.netlify.app/post/datatable/datatable-nse/ get() ne fctne que si largument na pas le même nom que la colonne du dt eval() ne fctne que si largument a le même nom que la colonne du dt modif_variable &lt;- function(dt, variable = &quot;x&quot;){ dt_copy &lt;- data.table::copy(dt) ## une copie pour la sécurité dt_copy[,c(variable) := get(variable) + 1] ## get() pour appeler un nom de variable entre guillemets (character) return(dt_copy) } Select columns whose name is variable, using a character vector , with = FALSE] IdTree = &quot;idTree&quot; Plot = &quot;plot&quot; SubPlot = &quot;subplot&quot; AssoVect &lt;- c(IdTree, Plot, SubPlot, TreeFieldNum) correspondances &lt;- unique(Data[, ..AssoVect]) ## &quot;..&quot; correspondances &lt;- unique(Data[, c(IdTree, Plot, SubPlot, TreeFieldNum), with = FALSE]) ## with = FALSE : the column names can be used as variables Cas plus générique : eval &amp; substitute eval() exécute une expression substitute() : attribut les valeurs, substitut les variables (=names=symbol) par leurs valeurs as.name() : refer to R object by their name -&gt; avoid conflict and work with user variables names df1 &lt;- data.table(sp = LETTERS[1:10], x = rnorm(10)) ## cas où l&#39;arg n&#39;a pas le même nom que la col df2 &lt;- data.table(species = LETTERS[1:10], var = rnorm(10)) ## cas où l&#39;arg a le même nom que la col species = &quot;sp&quot; var = &quot;x&quot; fun &lt;- function(df, species, var){ env &lt;- lapply(list(.species = species, .var = var), as.name) ## environment eval(substitute( { df[, p := paste(.species, .var)] df[, q := paste(.species, &quot;_&quot;, .var)] ## le . devant le nom n&#39;est pas nécessaire c&#39;est juste mieux de distinguer pour le codeur }, env)) return(df) } fun(df1, &quot;sp&quot;, &quot;x&quot;) ## cas où l&#39;arg n&#39;a pas le même nom que la col df1 fun(df2, &quot;species&quot;, &quot;var&quot;) ## cas où l&#39;arg a le même nom que la col df2 2.24.3 .SD (Subset of Data) .SD permet dappliquer la même opération sur plusieurs colonnes. .SDcols : sélection des colonnes sur lesquelles appliquer lopération (par défaut elles sont toutes prises) -&gt; syntaxe très puissante, compact et lisible 2.24.4 lapply+.SD pour des fonctions de statistiques descriptives ## fabriquer une table statistique DT[, lapply(.SD, min), .SDcol = &quot;a&quot;, by = c] mes_statistiques &lt;- function(x) return(c(mean(x), var(x), quantile(x, probs = c(.25,.5,.75)))) data_agregee &lt;- dt[, ## i lapply(.SD, mes_statistiques), ## j (expression) by = &quot;Species&quot;, ## by (group) .SDcols = c(&quot;Petal.Width&quot;,&quot;Petal.Length&quot;)] data_agregee[, &#39;stat&#39; := c(&quot;moyenne&quot;,&quot;variance&quot;,&quot;P25&quot;,&quot;P50&quot;,&quot;P75&quot;), by = &quot;Species&quot;] ## add a col to define the values in rows data_agregee 2.24.5 Des data.table poupées russes Facilite la parallélisation DT[, list(list(.SD)), by = Group] cl &lt;- makeCluster(2) DT[, clust := list(parLapplyLB(cl, V1, function(X){kmeans(X,2)$cluster}))] "],["spatial-data-cours.html", "Cours 3 Spatial data cours 3.1 Types de données spatiales 3.2 ggplot 3.3 Les rasters 3.4 Les objets spatialisés en R 3.5 Shapefiles 3.6 Systèmes de coordonnées de références (CRS)", " Cours 3 Spatial data cours library(tidyverse) library(sf) Mapper des points dont on a la longitude et la latitude : ggplot(mapping = aes(x = lon, y = lat)) + geom_point() ggmap : ajoute des couches dimages (fond de carte) téléchargées depuis des services de cartorgaphie en ligne. library(&quot;ggmap&quot;) east_canada &lt;- get_stamenmap(bbox = c(left=-81, right = -59, bottom = 44, top = 51),#boîte de coordonnées délimitant la carte à produire zoom = 6, #zoom = niv de détails (2 suffisant pour une carte du monde) maptype = &quot;terrain&quot;) # type de carte ggmap(east_canada) + geom_point(data = weather, mapping = aes(x = lon, y = lat)) ## ou ggmap(east_canada, base_layer = ggplot(weather, aes(x = lon, y = lat))) + geom_point() ##base_layer permet deffectuer des fecettes et déviter de spécifier la source des données dans toutes les couches subséquentes. Maptype : - terrain : efficace mais peu esthétique - toner-lite : pour limpression - watercolor : pour le web 3.1 Types de données spatiales Les données spatiales sont des données localisées dans un système de coordonnées de référence (CRS) Données vectorielles (en général en 2D, 3D si on prend en compte laltitude: Données ponctuelles : points Données linéaires : série de points (route, rivière) Données de polygone : aire délimitée par des points (champ, bassin versant) Données raster: grille (image satellite où chaque pixel est associé à un recouvrement foliaire.) Données génériques : shapefiles et geojson Données spécialement conçus pour R : sf 3.2 ggplot geom_polygon : : pour créer des polygones coord_map geom_path() : pour créer des lignes geom_tile() : visualiser une grille -&gt; graphique de type heatmap *geom_sf() : pour afficher les objets sf Cartes intéractives (mode leaflet) : tmap_mode(view) Pour revenir en mode statique : tmap_mode(plot) 3.3 Les rasters = données (variable(s)) associées à une grille comprenant les combinaisons de longitudes et latitudes. Raster = * une en-tête : - syst de coordonnées de référence - lorigine : généralement les coordonnées du coin bas-gauche de la matrice (mais le package raster prends le coin haut-gauche par défaut) - dimensions : nbr de colonnes, de lignes, la résolution de la taille des cellules * une matrice de cellules équidistantes (~pixels) : la matrice ne stocke qu1 coordonnée de la cellule : lorigine -&gt; + efficace et rapide que le traitement des données vectorielles. 1 cellule = 1 ou plsrs valeurs, ou NA (numérique ou catégorique) = la valeur moyenne (ou majoritaire) de la zone quelle couvre. Cependant, dans certains cas, les valeurs sont en fait des estimations pour le centre de la cellule. linformation spatiale est implicitement donnée par létendue spatiale et le nombre de lignes et de colonnes dans lesquelles la zone est divisée. Les données raster sont en général continues (altitude, T°, densité de pop), mais peuvent-être aussi catégoriques (type de sol) mais dans ce cas une représentation vectorielle pourrait être plus appropriée. expand.grid() : créer une grille de paramêtres : associer des coordonées à une variable grid &lt;- expand.grid(lon = seq(from = -80, to = -60, by = 0.25), lat = seq(from = 45, to = 50, by = 0.25)) grid &lt;- grid %&gt;% mutate(z = 10*sin(lon*lat) - 0.01*lon^2 + 0.05*lat^2) # créer une variable spatialisée grid %&gt;% head() ggplot(grid, aes(lon, lat)) + geom_tile(aes(fill = z)) Géostatistique = étude statistique des variables spatiales 3.4 Les objets spatialisés en R 3.4.1 Données vectorielles Objets géoréférencés R (=variables (data.frame) liés à des coordonées (sfc)): sf Packages : sp, sf (mieux adapté au tidy) Transformer un dataframe en objet sf : st_as_sf() : - type de géométrie (geometry type: POINT (= sfg objets)), - les limites des objets (bbox: ), - le système de référence (epsg ou proj4string: ) - le tableau descriptif Revenir à une table non spatialisée : st_drop_geometry() Les objets sfg peuvent être créés avec : * un vecteurs numérique * une matrice * une liste plot(st_point(c(5, 2))) # XY point (2D) st_point(c(5, 2, 3)) # XYZ point (3D) st_point(c(5, 2, 1), dim = &quot;XYM&quot;) # XYM point st_point(c(5, 2, 3, 1)) # XYZM point ## the &#39;rbind&#39; function simplifies the creation of matrices ### MULTIPOINT multipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2)) plot(st_multipoint(multipoint_matrix)) ### LINESTRING linestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)) plot(st_linestring(linestring_matrix)) ### POLYGON polygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))) plot(st_polygon(polygon_list)) ### POLYGON with a hole polygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)) polygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4)) polygon_with_hole_list = list(polygon_border, polygon_hole) plot(st_polygon(polygon_with_hole_list)) ### MULTILINESTRING multilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), rbind(c(1, 2), c(2, 4))) plot(st_multilinestring((multilinestring_list))) ### MULTIPOLYGON multipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))), list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))) plot(st_multipolygon(multipolygon_list)) ### GEOMETRYCOLLECTION gemetrycollection_list = list(st_multipoint(multipoint_matrix), st_linestring(linestring_matrix)) plot(st_geometrycollection(gemetrycollection_list)) ##&gt; GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), ##&gt; LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)) 3.4.1.1 Simple feature columns (sfc) une sfc est une liste dobjets sfg, de meme type géométrique ou non. point1 = st_point(c(5, 2)) point2 = st_point(c(1, 3)) points_sfc = st_sfc(point1, point2) #st_sfc() crée une liste d&#39;objets sfg points_sfc st_geometry_type(points_sfc) sfc to sfg : st_point(as.numeric(unlist(sfc))) (ex ici point) st_read() : pour charger des données (ex:shapefiles) au format sf Les tableaux sf sont manipulables sous tydiverse. plot() : par défaut crée un multi-panel plot : un graph par variable. Pour ne ploter que les contours (la géométrie): quebec %&gt;% st_geometry() %&gt;% plot() # ou bien plot(st_geometry(quebec)), ou bien plot(quebec %&gt;% select(geometry)) Jointures spatiales (intersections de polygones, unions, différences) -&gt; 1 nouvelle géométrie Attribuer un crs à un objt sf ou sfc : st_set_crs(objtsanscrs, st_crs(objtaveccrs)) Exporter un tableau sf en format csv incluant la géométrie : st_write(obj = tableau,dsn = tableau.csv, layer_options = GEOMETRY=AS_XY) Si la géométrie nest pas consituée de points, il faudra préalablement transformer les polygones en points avec st_cast() 3.4.2 Données raster Package : raster grilles svt enchasées dans des images tif géoréférencées. 1 image tif = 1 ou plsrs bandes (variables) raster() : importe des données raster à 1 bande (names dans les infos) brick() : importe des données raster à plsrs bandes (names dans les infos) stack() : permet de connecter plusieurs objets raster stockés dans différents fichiers ou plusieurs objets en mémoire Les informations des objets RasterLayer et RasterBrick peuvent être extraites par les fonctions : extent(), ncell(), nlayers() et crs(). La fonction plot() permet dexplorer les données en créant 1 graphique par bande. Les tif sont trés volumineux. Si lon nas pas besoin dune si haute résolution, on peut simplifier le raster avec raster::aggregate() 3.4.3 Travailler sur du vectoriel &amp; du raster Le package raster ne supporte pas le format sf, il faut donc préalablement convertir en sp : poly_sp &lt;- as(poly, Spatial) (poly étant ici un polygone) 3.4.4 Opérations sur Raster Intersection (ce quil y a en commun) entre un polygone et un raster : mask() Découper (rectangulaire selon les limites de lobjet) : crop() Extraction : extract() ##Pour effectuer un calcul sur lintérieur du polygone avec extract() on spécifie le raster, le polygone et la fonction! extract(canopy, poly_sp, fun = mean) # &quot;canopy&quot; = raster, &quot;poly_sp&quot; = polygone 3.5 Shapefiles Contiennent plsrs fichiers : fichier .prj : informations du système de coordonnées 3.6 Systèmes de coordonnées de références (CRS) 3.6.1 Système de coordonnées géographiques Valeurs : Longitude/latitude La Terre est représenté sphérique ou ellipsoïde (+juste). Modele ellipsoïde, 2 paramètres: - rayon équatorial - rayon polaire 3.6.2 Système de référence de coordonnées pojetées basé sur des coordonées catésiennes sur une surface plane. et basés sur les systèmes de coordonnées géographiques une origine axes x &amp; y une unité (ex: le mètre) "],["c.html", "Cours 4 C++", " Cours 4 C++ Intérêt : + rapide Package Rcpp : simplifie lintégration de code C++ dans R Inconvénients : difficile à débugger -&gt; ny écrire que du code maitrisé et méritant cet effort Sous R : + préparation/vérification des données + traitement et la présentation des résultats. C++ : + dans un package (dossier src) + dans un doc C++ (.cpp) + dans RMarkdown avec insertion chunk Rcpp sourceCpp() : compilation du .cpp Créer une fonction C++ : calculer le double dun vecteur numérique #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector timesTwo(NumericVector x) { return x * 2; } -&gt; Une fct R du meme nom que la fct C++ sest créée timesTwo(1:5) "],["rmarkdown.html", "Cours 5 Rmarkdown 5.1 Titre 5.2 Table 5.3 Figure 5.4 Equations", " Cours 5 Rmarkdown texte 5.1 Titre 5.1.1 Sous-titre Liste : chat chien oiseau Liste numérotée : Liste numérotée on peut laisser 1. et il met les bons numéros italique ou italique gras ou gras gras&amp;italique citation Pour passer à la ligne suivante/faire un noyveau paragraphe : finir par espaces la ligne ## Chunk raccourci clavier pour générer un chunk : CTRL + ALT + I Chunk options Afficher une valeur dans le texte : 1+2 = r 1+2 5.2 Table ##la fonction &quot;kable&quot; dans &quot;knitr&quot; knitr::kable(head(cars), #les en-têtes de &quot;cars&quot; caption = &quot;Légende.&quot;) 5.3 Figure library(tidyverse) ggplot(cars, aes(speed, dist))+ geom_point() 5.4 Equations \\(\\alpha\\) \\[Y \\sim\\mathcal N(\\mu,\\sigma)\\frac{1}{1+e}\\] "],["bookdown.html", "Cours 6 Bookdown 6.1 Fichiers particuliers", " Cours 6 Bookdown R proj particulier pour le bookdown 6.1 Fichiers particuliers index.rmd : fichier pour indiquer le header de ts les fichiers, écrit la préface _bookdown.yml : def construction livre book_filename: &quot;My_cours&quot; delete_merged_file: true # supprimer le fichier intermediaire de la compilation language: ui: chapter_name: &quot;Cours &quot; output_dir: &quot;docs&quot; # dossier de stockage de la compilation _output.yml : def construction des sorties bookdown::gitbook: config: toc: before: | &lt;li&gt;&lt;a href=&quot;./&quot;&gt;My_cours&lt;/a&gt;&lt;/li&gt; after: | # lien &quot;source&quot; vers le dépot Github &lt;li&gt;&lt;a href=&quot;https://github.com/VincyaneBadouard/My_cours&quot; target=&quot;blank&quot;&gt;Source&lt;/a&gt;&lt;/li&gt; collapse: section # pour ne pas afficher les sous-parties ds le menu deroulant includes: in_header: hypothesis.html # permet les comentaires dans le doc (open review) before_body: open_review_block.html scroll_hillight: yes # mise en couleur qd on est dans la partie "],["intégration-continue.html", "Cours 7 Intégration continue 7.1 Travis 7.2 Codecov", " Cours 7 Intégration continue Intégration continue = confier à un service externe certaines taches (tests, production de docs, tricot) pour limiter la perte de temps. 7.1 Travis nécessaire douvrir un compte sur le site possible de sauthentifier avec son compte GitHub Lien Travis-github : clé privée PAT (Personal Access Token) Créer un jeton : Settings &gt; Developer settings &gt; Personal access tokens &gt; Generate new token &gt; décrire Travis et donner lautorisation repo &gt; Generate token et enregistrer le jeton qqpart, sinon cest perdu. Mon jeton déjà créé : 2c731e9c305bb450d691bdea233ede3e7f7b1d88 a ne pas perdre Activation du dépôt: Sur le site de Travis &gt; settings &gt; settings du repository &gt; Name : GITHUB_TOKEN, Value : &gt; add La liste des dépôts GitHub est présentée. Pour en activer un, cliquer sur linterrupteur gris à côté de son nom 7.1.1 Script de contrôle de Travis fichier: .travis.yml. 7.2 Codecov Evalue la proportion testé du code 1) nécessaire douvrir un compte sur le site 2) possible de sauthentifier avec son compte GitHub "],["function-creation.html", "Cours 8 Function creation 8.1 Étapes de développement : 8.2 Structure : 8.3 Nommer ses arguments 8.4 Valeurs par défaut 8.5 évaluation de la fonction 8.6 Vérification de la classe des arguments 8.7 Largument fun 8.8 Largument  8.9 Types de fonction 8.10 Retourner un résultat 8.11 Fonctions de message et darrêt de fonction 8.12 Interaction avec lutilisateur 8.13 Iteration 8.14 Parallelisation 8.15 Choses à savoir 8.16 Débogage tips 8.17 Où écrire ses fcts ? 8.18 Comment les utiliser ? 8.19 Plusieurs fonctions internes - passation dinfos", " Cours 8 Function creation 8.1 Étapes de développement : Planifier le travail (pas de programmation encore) : définir clairement la tâche à accomplir par la fonction et la sortie quelle doit produire, prévoir les étapes à suivre afin deffectuer cette tâche, identifier les arguments devant être fournis en entrée à la fonction. Développer le corps de la fonction Écrire le programme par étapes, dabord sans former la fonction, en commentant bien le code et en travaillant sur des mini-données test. Pour chaque petite étape ou sous-tâche, tester interactivement si le programme produit le résultat escompté (tester souvent en cours de travail, ainsi il y a moins de débogage à faire). Créer la fonction à partir du programme développé. Documenter la fonction. Tester la fonction : sauvegarder nos tests et bien les structurer, car ils serviront souvent. Si nous rencontrons des comportements indésirables lors des tests, déboguer la fonction : cerner le ou les problèmes, apporter les correctifs nécessaires à la fonction (que ce soit dans son corps ou dans liste de ses arguments), adapter la documentation et les tests au besoin, faire tourner de nouveau les tests, répéter ces sous-étapes jusquà ce que les tests ne révèlent plus aucun problème à régler ou aucune amélioration à apporter. 8.2 Structure : nomdemafonction&lt;-function(variable1,variable2...) { #ici on met le contenu de la fonction (généralement on effectue des transformations aux variables passées en argument) return(Variabledesortie) ## il s&#39;agit du résultat que va renvoyer la fonction (non négligeable!)! c&#39;est bien le but d&#39;une fct! } #une fois la fonction créée on peut l&#39;utiliser: nomdemafonction(varA,varB,...) Une fct normalement constituée ne travaille directement que sur ses arguments et non sur les objets stockés dans la console. Tous les objets qui seront utilisés dans le script doivent avoir été créés dans le script. Les seules exceptions à cette règle sont les arguments qui eux sont définis dans len-tête. Exemple ## Calculer le coefficient de variation (CV) (=écart type/moyenne) d&#39;une série de valeur. cv &lt;- function(x){ ## x est un vecteur contenant une série de valeurs moy &lt;- mean(x) ## moyenne de x s &lt;- sd(x) ## ecart type de x rslt &lt;- s/moy ## calcul du CV rslt #la fonction retourne le résultat } 8.3 Nommer ses arguments Noms habituels : x, y, z: vectors. w: a vector of weights. df: a data frame. i, j: numeric indices (typically rows and columns). n: length, or number of rows. p: number of columns. Règle : Si les arguments des fonctions appelées sont donnés de la forme name = object, ils peuvent être écris dans nimporte quel ordre. Dans le cas contraire, il faut respecter lordre des arguments. fun1 &lt;- function(data, data.frame, graph, limit) { [function body omitted] } ## Alors la fonction peut être invoquée de plusieurs manières, par exemple: ans &lt;- fun1(d, df, TRUE, 20) ## arguments dans l&#39;ordre ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df) ## arguments dans le désordre et donc nommés 8.4 Valeurs par défaut fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { ... } #on attribue une valeur à l&#39;argument dès l&#39;écriture 8.5 évaluation de la fonction return() renvoie la dernière valeur calculée nom_de_fonction &lt;- function(arguments) { instructions return(valeur) #non négligeable! c&#39;est bien le but d&#39;une fct! } 8.6 Vérification de la classe des arguments class(x) 8.7 Largument fun = passer une fonction a une autre fonction en argument col_summary &lt;- function(df, fun) { out &lt;- vector(&quot;double&quot;, length(df)) for (i in seq_along(df)) { out[i] &lt;- fun(df[[i]]) } out } col_summary(df, median) col_summary(df, mean) 8.8 Largument  Il est possible dutiliser le symbole  dans les paramètres dune fct pour indiquer que tous les paramètres supplémentaires seront transmis aux autres fonctions internes. fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, ...) { [omitted statements] if (graph) par(pch=&quot;*&quot;, ...) [more omissions] } 8.9 Types de fonction 8.9.1 Appel récursif La récursivité est une démarche qui fait référence à lobjet-même de la démarche à un moment du processus (=poupée russe) Une fct peut sappeller elle-même, tant quil existe une condition darrêt. ## Scalaire : nombre réel ## Vecteur : serie de valeurs ## Sur scalaire factorielle &lt;- function(n) { if (n==1) resultat &lt;- 1 ## scalaire booléen ## arrêt de la récursion (n=1 est la condition d&#39;arrêt) else resultat &lt;- factorielle(n-1)*n ## appel récursif (si n différent de 1) return(resultat) } ## Sur vecteur factorielle &lt;- function(n) { indice &lt;- (n == 1) ## vecteur de booléens if (all(indice)) return(n) ## arrêt de la récursion (n=1 est la condition d&#39;arrêt) n[!indice] &lt;- n[!indice]*factorielle(n[!indice] - 1) ## appel récursif (si n différent de 1) return(n) } 8.9.2 Fct anonyme dans une autre fonction outer(x, y, function(x, y) x * y^2) ## une fonction est mise en argument d&#39;une autre fonction ## [,1] [,2] [,3] ## [1,] 16 25 36 ## [2,] 32 50 72 ## [3,] 48 75 108 8.10 Retourner un résultat Une fonction retourne le résultat de la dernière expression du corps de la fct. -&gt; donc il ne faut pas que la dernère expression soit une affectation (&lt;-), sinon on ne pourra pas affecter le résultat à un objet On peut retourner un résultat spécifique, à nimporte quel endroit de la fonction avec la fct return() Si le résultat que lon veut retourner est codé par la dernière expression, return() est inutile. return se met plutot à la fin dune fct, sauf cas exeptionel (if), car la fct naffiche plus les msg/stop si le return sest effectué. Lorsquune fonction doit retourner plusieurs résultats, il est en général préférable davoir recours à une liste nommée. Retourner plsrs outputs : Outputs &lt;- list(objt1 = objt1, objt2 = objt2) return(Outputs) Si une fct retourne plsrs ouputs, elle doit toujours les retourner. Sil ne sont générés que sous condition, créer un objet vide du m^me nom lorsque la condition nest pas respectée. 8.11 Fonctions de message et darrêt de fonction message() = message diagnostique (juste informatif) warning() = message derreur (problème non rédhibitoire (ex: syntax)) stop() = message derreur + arrêt du code (rédhibitoire) stop est une fonction derreur, si cest juste une question de prérequis, il faut utiliser if pas stop. Un stop dans une fonction interne arrête également la fonction dans laquelle elle est inscrite. try : essaye la fonction interne sans stopper la fonction englobante. catch : capture le résultat du try quel quil soit. verbose : par défaut = TRUE dans R donc si on veut tjrs tout afficher il ne sert à rien de le mentionner Pour demander confirmation à lutilisateur : readline(pay attention to me!(press enter to continue)) 8.12 Interaction avec lutilisateur fun &lt;- function() { ANSWER &lt;- readline(&quot;Are you a satisfied R user? &quot;) ## question if (substr(ANSWER, 1, 1) == &quot;n&quot;) ## check the answer cat(&quot;This is impossible. YOU LIED!\\n&quot;) ## re-prompt else cat(&quot;I knew it.\\n&quot;) } if(interactive()) fun() 8.13 Iteration https://r4ds.had.co.nz/iteration.html itérer n fois : replicate(n, expr, simplify = F) (renvoie une liste) ou purrr::rerun(n, expr) ou purrr::map(1:n, ~ expr) ou lapply(seq_len(n), function(x) fun()) ## fun0 a function ## fun1 a a function to iterate fun0 with a n argument fun1 &lt;- function(n, x) replicate(n, fun0(x = x)) fun1(n, x) set.seed(1) fun0 &lt;- function(x) as.list(matrix(c(1, 1, 1, x + rnorm(1)), nrow = 2)) n &lt;- 1000 fun0(1) library(microbenchmark) mb &lt;- microbenchmark( repl = {replicate(n, fun0(1), simplify = FALSE)}, reru = {purrr::rerun(n, fun0(1))}, map = {purrr::map(1:n, ~fun0(1))}, lap = {lapply(seq_len(n), function(x) fun0(1))}, times = 1000L ) mb mb &lt;- microbenchmark( suit = {1:n}, rep = {rep(1, n)}, seq_len = {seq_len(n)}, seq_along = {seq_along (n)}, ## le + rapide c = {c(1:n)}, times = 1000L ) mb repeat() : répète à linfini si on ne met pas une condition et un break dedans. Boucle for ou boucle while Encapsuler une boucle dans une fonction apply family (base) : apply(), lapply(), tapply(), etc map family (purrr) (+ rapides car écrite en C): map() (makes a list), map_lgl() (logical vector), map_int() (integer vector), map_dbl() (double vector), map_chr() (character vector). Les map ne produisent que des vecteurs, pas de matrice) Peuvent apliquer des fonctions ou des formules (https://r4ds.had.co.nz/iteration.html). Les boucles for ne sont plus lentes depuis de nombreuses années. Le principal avantage de lutilisation de fonctions comme map() nest pas la vitesse, mais la clarté : elles rendent votre code plus facile à écrire et à lire. Modif de loutput : transposer une liste (inverser la tructure) : purrr::transpose() 8.14 Parallelisation https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html https://bookdown.org/rdpeng/rprogdatascience/parallel-computation.html Why : for time and memory 1 processor = multiple cores = multiple computations to be executed at the same time. R is sequential and uses 1 processor Plus simple de paralléliser des taches indépendantes, 1 par coeur. 1 tâche = 1 fct Packages : parallel, future, foreach, doParallel diffèrent selon les syst dexploit on dirait Parallel functions : - detectCores() : détecte le nbr de coeur de la machine. - mclapply() : utiliser plsrs coeurs sur un ordinateur local (= parallelized version of lapply) (pas sous windows) - makeCluster() and clusterApply() : utiliser plusieurs processeurs sur des machines locales (et distantes) - clusterExport() : à distance Sous windows on ne peut pas paralléliser en local il faut donc un cluster : - créer un cluster : cl &lt;- makePSOCKcluster(nbr de copies de R à créer) (à défaut davoir des coeurs il crée plsrs copies de R) - créer lenvmt du cluster : clusterExport(cl, varlist = c(var1, var2), envir = environment()) - paralléliser : parLapply(cl, seq_along(iter), myfun) - arrêter le cluster : stopCluster(cl) https://stackoverflow.com/questions/17196261/understanding-the-differences-between-mclapply-and-parlapply-in-r library(parallel) cl &lt;- makePSOCKcluster(4) ## créer un cluster myfun &lt;- function(i) { Sys.sleep(1); i } ## the function parLapply(cl, 1:8, myfun) ## parallelization stopCluster(cl) ## stop the cluster Sur des boucles : - foreach sequential operator : %do% - doParallel parallelizable operator : %dopar% ## nonparallel for loop for (i in 1:3) { print(sqrt(i)) } ## nonparallel foreach loop library(foreach) system.time({ foreach (i=1:3, .combine=c) %do% { ## .combine=c si on veut unlist l&#39;output, .combine=rbind si on veut un df sqrt(i) } }) ## doParallel = foreach parallel adaptor for the &#39;parallel&#39; package library(doParallel) numCores &lt;- parallel::detectCores(logical = FALSE) ## FALSE to have the physical cores system.time({ registerDoParallel(numCores) foreach (i=1:3) %dopar% { sqrt(i) } }) When youre done, clean up the cluster : stopImplicitCluster() 8.15 Choses à savoir Une fct a un environnement propre (ses var sont locales et ne vont pas dans lenvmt de travail): ainsi pas de conflit. Eviter donc dutiliser des objets provenant de lenvmt de travail. Pour cela le mieux est de garder son environnement global tjrs vide (vider tt lenvrmt global : rm(list = ls())) On peut définir une fonction à lintérieur (= fonction interne) dune autre fonction. Cette fonction sera locale à la fonction dans laquelle elle est définie. 8.16 Débogage tips Lorsque Browse[1]&gt; saffiche dans la console, on peut écrire des commandes utilisant lenvironnement de la fonction en bug, et donc la travailler. Un booléen T/F ne marche pas si des NA existe Lorsquune fct ne retourne pas le résultat attendu, placer des commandes print à lintérieur de la fct, afin de suivre les valeurs prises par les différentes variables. On peut même écrire print(1) après la 1ère ligne, print(2) après la 2eme, ainsi de suite pour savoir à quelle ligne se trouve lerreur. Quand ce qui précède ne fonctionne pas, ne reste souvent plus quà exécuter manuellement la fonction : définir dans lespace de travail tous les arguments de la fonction, puis exécuter le corps de la fonction ligne par ligne. La vérification du résultat de chaque ligne permet généralement de retrouver la ou les expressions qui causent problème. ou masquez avec le « ## » toutes les commandes que vous venez déditer ou rajouter, sauf la 1ere, Sauvez, et testez le fichier afin de voir si cette ligne est correcte. Si « source » fonctionne, enlevez le prochain dièse. Noubliez pas de sauver et de « sourcer » à chaque test. 8.17 Où écrire ses fcts ? Dans un fichier .R indépendant nom de fichier = nom de la fonction 8.18 Comment les utiliser ? Enregistrer le code de la fct dans lenvmt : source(nomfct/file.R) 8.19 Plusieurs fonctions internes - passation dinfos ## Main : fonction englobante main &lt;- function(inventory){ inventory.volume &lt;- getvolume(inventory) rm(inventory) inventory.final &lt;- filtervolume(patate = inventory.volume) rm(inventory.volume) return(inventory.final) } ## Fonctions internes getvolume &lt;- function(inventory){ inventory &lt;- inventory %&gt;% mutate(v = 2*d) return(inventory) } filtervolume &lt;- function(patate){ poireau &lt;- patate %&gt;% filter(v &gt; 0) return(poireau) } ## test inventory &lt;- data.frame(id = 1:10, d = rnorm(10)) main(inventory) "],["package-creation.html", "Cours 9 Package creation 9.1 References 9.2 Les packages R nécessaires 9.3 Creation du package 9.4 Tips de codeur 9.5 Eviter les messages derreurs 9.6 Commandes 9.7 Importation de fonctions 9.8 Créer des classes pour ses objets en plus de ceux de base 9.9 Créer une méthode générique 9.10 tidyverse 9.11 Vignette 9.12 Site du package : Pkgdown 9.13 Des petits messages à lutilisateur 9.14 C++ 9.15 Biblio 9.16 Where stock my data in my package 9.17 Charger ces data 9.18 Tests 9.19 Un package pour tous 9.20 CRAN 9.21 Debugger 9.22 Versioning", " Cours 9 Package creation 9.1 References The original bible : https://r-pkgs.org/index.html en francais : https://www.imo.universite-paris-saclay.fr/~goude/Materials/ProjetMLF/editer_package_R.html Eric Marcons cours : https://ericmarcon.github.io/Cours-travailleR/ 9.2 Les packages R nécessaires Télécharger des packages daide à lorganisation et structure, nécessaire à lécriture dun package : ## install.packages(c(&quot;usethis&quot;, &quot;roxygen2&quot;, &quot;devtools&quot;, &quot;testthat&quot;, &quot;covr&quot;, &quot;goodpractice&quot;)) ## ## library(usethis) #automatise la création des dossiers, vignette, site ## ## library(roxygen2) #permet dautomatiser la documentation obligatoire des packages ## ## library(devtools) #boîte à outils, permettant notamment de construire et tester les packages ## # roxygen2::roxygenise()#refresh de la documentation ## ## library(testthat) # Create test units ## ## library(covr) # Test coverage report() ## ## library(available) #vérifier la disponibilité du nom de votre package ## ## # available::available(&quot;LoggingLab&quot;) # TreeData ## ## library(goodpractice) # Bonnes pratiques dans la construction de package (functions and syntax to avoid, package structure, code complexity, code formatting) ## gp(system.file(package = &quot;Maria&quot;)) #trouve les mauvaises pratiques de notre package ## si on avait une ancienne version de withr pour rstan ## remove.packages(&quot;withr&quot;) ## install.packages(&quot;withr&quot;) 9.3 Creation du package New Project &gt; New Directory &gt; R package using devtools Nom du package : pas despace, pas dunderscore, ne pas commencer par un chiffre et en minuscule Build &gt; Install and restart construit et charge le package dans R 9.4 Tips de codeur Mesurer le temps dexécution dun code : system.time ou microbenchmark (fct1,fct2) pour des codes trés courts. Ce sont les médianes des temps de calcul quil faut comparer. Détacher un package de lenvironnement : unloadNamespace() Définitions Charger/Attacher un package : pkg::fct = pas attaché library(pkg) = attaché dans un cas comme dans lautre, le package est chargé (load) : on lutilise. Trouver les non ASCII characters : tools::showNonASCIIfile(R/zzz.R) les lignes doivent faire 80 charactères max 9.5 Eviter les messages derreurs Ne pas sauter de lignes dans DESCRIPTION file 9.6 Commandes Build &gt; Install and restart permet de tester des modifications de code check ou devtools::check() permet de vérifier son code (màj de la documentation (dossier man), tests sur le code, renvoie erreurs et avertissements) git branch -d main dans la console permet de supprimer la branche main de git Documentation-exporter une fonction : placer le curseur dans la fonction et appeler le menu Code &gt; Insert Roxygen Skeleton (ou CTRL + ALT + SHIFT + R): roxygen2 la déclarera dans NAMESPACE après un check raccourcir les lignes du squelette : ctrl + shift + / 9.6.1 Comprendre le Skeleton = sera la page daide de la fonction ! @include : mentionne des fichiers .R appelés dans le fichier @import : importer lintégralité des fonctions du package (seulement si on utilise bcp de fcts du package (ex: ggplot2) @importFrom package fct : aller chercher une fonction dans un package (à privilégier) @param : y décrire le paramètre et citér sa classe @return décrire le résultat de la fonction @export déclare que la fonction est exportée : elle sera donc utilisable dans lenvironnement de travail Pour un exemple quon ne veut pas encore checké 9.6.2 R folfer Contiendra 1 ou plsrs fichiers .R contenant nos fonctions. 1 fichier peut contenir 1 fonction ou on peut y rassembler plsrs fonctions regroupables 9.6.3 nompackage.R file = commentaires pour roxygen2 = page daide du package (=1er bloc) (visible avec package?Maria) = supplément de la vignette 9.6.4 NAMESPACE file gestion des noms des objets = interaction du package avec le monde exterieur : importation dautres fonctions/packages, exportation de nos fonctions. 9.6.5 DESCRIPTION file Depends: liste des packages dorigine de chaque générique Depends: R (&gt;= 2.10), ggplot2, graphics Les alinéas sont nécessaires 9.6.6 .Rbuildignore = fichiers dans le package pour le constructeur, mais qui ne seront pas chargés avec le package pour lutilisateur. 9.7 Importation de fonctions le package dappartenance de la fonction doit obligatoirement être déclaré : DESCRIPTION &lt; Imports: nom package, nom package Le package tydiverse ne doit pas être importé car trés changeant Import du pipe : usethis::use_pipe() Pour ne pas le faire à la main (préférable): usethis::use_package(stats) Importer la fonction dans nompackage.R : # @importFrom package fct dans le squelette de la fct (fichier.R) la fonction importée doit être trouvable dans lenvironnement du package en création : la meilleure pratique est de qualifier systématiquement les fonctions dautres packages dans le code avec la syntaxe package::fonction() (Sylvain dit que non) 9.8 Créer des classes pour ses objets en plus de ceux de base class(x) &lt;- MyClass ou class(y) &lt;- c(MyClass, class(y)) si on veut ajouter une classe aux classes de lobjet déjà existantes 9.9 Créer une méthode générique méthode générique = modèle de fonction, sans code, à décliner selon la classe dobjet à traiter (ex : plot). Une méthode générique est plus lente en calcul que ses fonctions dérivées qui sont spécialisées à une classe dobjet. meth_generique &lt;- function(x, ...) { UseMethod(&quot;meth_generique&quot;) } ## Fonction dérivée : meth_generique.class &lt;- function(x, ...) { return(x * 3L) #le suffixe L signifiant que 3 doit être compris comme un entier. } ##créer une fonction dérivée à partir d&#39;une fonction dérivée déjà existante print.multiple &lt;- function(x, ...) { print.default(x$y)#n&#39;afficher que le resultats y } Sa signature : ensemble de ses arguments Les fonctions dérivées de cette méthode devront obligatoirement avoir les mêmes arguments dans le même ordre et pourront seulement ajouter des arguments supplémentaires avant  (qui est obligatoire). 1er argument : x. Dépend de la classe de lobjet 9.10 tidyverse Tout package doit être compatible avec le tydiverse. pour permettre lutilisation de pipelines, largument principal = le premier fcts qui transforment des données doivent accepter un dataframe ou un tibble comme premier argument et retourner un objet du même format les méthodes plot() doivent être doublées de méthodes autoplot() avec les mêmes arguments qui produisent le même graphique quavec ggplot2. autoplot() : permet de visualiser tt type dobjet, meilleur que ggplot2. aes() devient aes_() et ajouter un ~ devant les noms des variables. R CMD CHECK NOTE no visible binding for global variable : mettre @importFrom rlang .data 9.11 Vignette Création usethis::use_vignette(nomdupackage) library(monpackage) dans le premier chunk. introduction à lutilisation du package chunk avec un exemple dutilisation Les packages utilisés par la vignette doivent apparaitre dans DESCRIPTION Cest un rmd donc ne pas oublier de kniter souvent Pour compiler la vignette (Build ne le fait pas) (et la voir dans la page daide du package): installer le package à partir de sa source : Pour mettre une copie de la vignette dans /doc (durant le dvp) : devtools::build_vignettes() On peut détruire ce qui est dans doc/ après usage. Le dossier est déclaré dans .Rbuildignore et .gitignore. Push sur Github puis devtools::install_github(DeveloperName/PackageName, build_vignettes = TRUE) Cette methode le permet aussi, mais plus triviale : https://www.r-bloggers.com/2020/05/how-to-add-a-vignette-to-a-package-in-rstudio/ Pour que le check ne construise pas la vignette : no-build-vignettes dans options &gt; check et build pckg Si le build renvoie une erreur relative à qpdf : il faut installer les Rtools et au bon endroit (voir 1.1.2 Rtools TravailleR dEric Marcon) 9.12 Site du package : Pkgdown https://pkgdown.r-lib.org/articles/pkgdown.html ! le dépot doit être public ! Création site du package (dossier docs): usethis::use_pkgdown() puis pkgdown::build_site() Use GitHub actions to automatically build and publish the site every time you make a change usethis::use_pkgdown_github_pages() Configures a GitHub Action to automatically build the pkgdown site and deploy it via GitHub Pages : usethis::use_github_action(pkgdown) Home page : index.md or README.md Reference : liens vers les pages daide de toutes les fcts du package. On peut les organiser voir le lien. Articles : vignettes News : NEWS.md Customise your site: https://pkgdown.r-lib.org/articles/customise.html 9.13 Des petits messages à lutilisateur Afficher des messages informatifs : cat() ex : cat(multiplied by, object$times, is:) donne multiplied by 2 is: 9.14 C++ un C++ file dans dossier src un .gitignore dans ce même dossier, dans lequel on met : \"# C binaries src/.o src/.so src/*.dll\" 9.15 Biblio Les réf biblio (sauf celles des .rmd (vignette, site) sont gérées automatiquement avec Rdpack et roxygen2 De notre zotero/mendeley vers : REFERENCES.bib dans le dossier inst Ajouter dans le fichier DESCRIPTION : RdMacros: Rdpack Imports: Rdpack Comment citer : citation(packagename) Biblio de la vignette : + créer un fichier bib + le déclarer dans lentête + citer avec @citation. On peut éviter de multiplier les fichiers bib en utilisant celui de RdPack qui est inst/REFERENCES.bib : dans la vignette, tu déclares le chemin relatif : bibliography: ../inst/REFERENCES.bib 9.16 Where stock my data in my package 9.16.1 Testing data: Just for me : in inst/extdata (inst pour installed) : external data (private) (en csv) -&gt; no need to document For the user (and me) : in data : internal data (= deliver with the package) (public) -&gt; need to document 9.16.2 Default data: Dataset : in data : internal data (= deliver with the package) (public) -&gt; need to document Valeurs par default darguments de fct : Fct darguments : si on veut passer des valeurs par défaut dans une fct, on peut les proposer en arguments de celle-ci. Sil y en a bcp, on peut créer une autre fct qui aura pour arguments ces valeurs par défaut et qui créé une liste de celles-ci. Cette dernière fct sera entrée comme argument de la 1ère. Ainsi nimporte quelle valeur peut être modifiée sans avoir à tout réécrire. fun1(A, B, arg = fun2(arg10 = FALSE)) Liste dans data : on peut aussi juste créer la liste et en faire un data que lutilisateur loadera, modifira, et injectera dans la fct en argument, mais ça lui demande donc du travail préliminaire. Global options in zzz file 9.16.2.1 Global options Where write options: in zzz file (in R folder), as a named list or vector (eg. pars &lt;- list(track_size = 2, method = EFI). Then you called pars$method.). Options = an object (here a list/vector) zzz file : on y met généralement les actions devant se réaliser au chargement du package. (https://cran.r-project.org/web/packages/GlobalOptions/vignettes/GlobalOptions.html#session_info) (https://github.com/mojaveazure/seurat-disk/blob/master/R/zzz.R) Inconvénients des options : on ne peut pas appliquer de apply sur différentes valeurs choisies dune même option. Documenter les options du package : dans un fichier .R dons le dossier R (regarder ?rstan_options pour inspiration) Modification des options par lutilisateur : options() http://www.endmemo.com/r/options.php If you modify global options() or graphics par(), save the old values and reset when youre done: old &lt;- options(optionsname = defaultvalue) save the old values on.exit(options(old), add = TRUE) reset when youre done To access the value of a single option, one should use, e.g., getOption(width) rather than options(width) which is a list of length one. 9.16.3 Exported data (in data/) accessible à lutilisateur ! usethis::use_data(data1, data2) : crée un fichier (.rda) pour chaque jeu de données/variable, dans le dossier data pas conseillé de prendre un autre format de fichier, celui-ci est pertinent (rapide et léger). DESCRIPTION file : LazyData: true -&gt; data dispo dès le chargement du package, ne chargeront quau besoin. comprésser un fichier : bzip2, gzip ou xz si le fichier data est une version transformée dune base de donnée, il est conseillé de mettre le code de transformation dans data-raw/ grace à : usethis::use_data_raw(nom du data) 9.16.4 Documenter ces données exportées Où : dossier R nommé data.R roxygen squeleton : ##&#39; Data title ##&#39; ##&#39; Data description ##&#39; ##&#39; @format A data frame with X rows and Z variables: ##&#39; \\describe{ ##&#39; \\item{var1}{description, in units} ##&#39; \\item{var2}{description, in units} ##&#39; ... ##&#39; } ##&#39; @source \\url{} commande d&#39;acquisition des données &quot;name&quot; 9.16.5 Internal data for a function (in R/sysdata.rda) Pour : stocker une base de données analysée/pré-calculée, dont a besoin une fonction. non-accessible à lutilisateur ! -&gt; pas à être documenté mise dans R/sysdata.rda grace à usethis::use_data(, internal = TRUE) si le fichier data est une version transformée dune base de donnée, il est conseillé de mettre le code de transformation dans data-raw/ grace à : usethis::use_data_raw() 9.17 Charger ces data Quand : pour les exemples et les tests, pas dans les fonctions ! Les fonctions ne manipulent que leurs propres objets (en 1er lieu leurs arguments). (Le mieux cest de garder son environnement global vide lors de la création de la fonction.) system.file(dossier, fichier, package = nompackage) : donne le chemin vers un fichier dun package, pour tout système dexploitation. load() : pour charcher les .rda. Ex : load(system.file(extdata, BrokenParacou6_2016.rda, package = Maria)) read_csv : pour charcher les csv data(nomdufichier) : charge le fichier sil est dans le dossier data du package 9.18 Tests Créer un dossier tests : usethis::use_testthat() écrire des tests à nos fonctions dans tests/testthat : usethis::use_test(name = nomdelafct) The test name should complete the sentence Test that . ## test_that(&quot;Math works&quot;, { ## expect_equal(1 + 1, 2) ## expect_equal(1 + 2, 3) ## expect_equal(1 + 3, 4) ## }) lancer tous les tests : devtools::test() (Ctrl + Shift + T) Each test is run in its own environment and is self-contained. chaque test sapplique sur les outputs de la fct testée, pas sur les objets internes dans les test, ne charger la function qu1 fois si possible pour limiter le temps de calcul (limité sur CRAN) Ne pas afficher les messages renvoyées par les fcts testées dans les tests : suppressMessages(fun()) package teststat : vérification que la fonction fonctionne et renvoie les valeurs quon veut package covr (juste copier report() dans la console) : qui dit quelle proportion du code est sous unités de tests (couverture) Devtools (https://testthat.r-lib.org/reference/index.html): expect_equal() is equal within small numerical tolerance? expect_identical() is exactly equal? expect_match() matches specified string or regular expect_message() displays specified message? expect_warning() displays specified warning? expect_error() throws specified error? expect_type() output inherits from certain class? expect_false() returns FALSE? expect_true() returns TRUE? logical-expectations() : Does code return TRUE or FALSE? expect_null() : Does code return NULL? expect_length : code return a vector with the specified length? equality-expectations() : code return the expected value? expect_vector() : Does code return a vector with the expected size and/or prototype? expect_named() : Does code return a vector with (given) names? comparison-expectations() : Does code return a number greater/less than the expected value? expect_setequal() : Does code return a vector containing the expected values? expect_output() : Does code print output to the console? try_again() : Try evaluating an expressing multiple times until it succeeds. make_expectation() : Make an equality test. test_examples() : Test package examples these functions have two arguments: the 1st is the actual result, the 2nd is what you expect. 9.19 Un package pour tous Pour tout système dexploitation : mentionnés dans le yaml de githubactions : il fait les tests pour chacun deux 9.20 CRAN tous les tests doivent êtres réussis sur min 2 syst dexploitation 0 notes/warning/error 9.20.1 Les tests Githubactions : pour un contrôle standard :usethis::use_github_action_check_standard() -&gt; R-CMD-check.yaml creation https://youtu.be/K4x-uqLl_m4 Codecov : test-coverage.yaml (https://github.com/r-lib/actions/tree/master/examples#test-coverage-workflow) (créer un secret pour le token sur github si le dépot est privé) Il faut créer un compte codecov 9.21 Debugger tapper ligne par ligne dans la console la partie qui coince Lorsque Browse[1]&gt; saffiche dans la console, on peut écrire des commandes utilisant lenvironnement de la fonction en bug, et donc la travailler. 9.22 Versioning https://r-pkgs.org/release.html#release-version major.minor.patch.9000 .9000 only for dvlmpt version major, nimor, patch for released version il peut y avoir des versions de dvlp entre released versions For development version: 9000 +1 / commit for example. You can choose your unit For released version: patch : just debuging, no addings minor : debuging, addings, with backward compatibility (same functions and arguments names) major : substantive changes, not backward compatible, affect many users "],["shiny-cours.html", "Cours 10 Shiny cours 10.1 Packages 10.2 Tips codeur 10.3 Shiny: 10.4 Structurer lappli 10.5 Créer linterface 10.6 Gérer les intéractions 10.7 Enrichir lappli 10.8 Autres packages 10.9 Mise en ligne et partage de lappli 10.10 Module 10.11 Autres sources cours", " Cours 10 Shiny cours 10.1 Packages library(shiny) # Web Application Framework for R library(bslib) # aesthetic, thème et feuilles de style ## bslib::bootswatch_themes() # pour voir ts les thèmes library(shinydashboard) ## library(bs4Dash) # dashboard aussi. restart R session si on passe d&#39;un pkg à l&#39;autre (dont mode jour/nuit mais mal fait) library(shinyjs) # Improve the User Experience library(dplyr) library(ggplot2) library(thematic) # Aesthetic, Unified and Automatic &#39;Theming&#39; of &#39;ggplot2&#39;, &#39;lattice&#39;, and &#39;base&#39; R Graphics library(DT) # Interactive table library(leaflet) # Interactive Web Maps library(plotly) # Interactive Web Graphics 10.2 Tips codeur à la fin dune grosse parenthèse/accolade préciser de quoi cest la fin #### titre partie #### ou tirets ou égales pour faire des parties déroulantes dans le code 10.3 Shiny: Package gratuit dvp par Rstudio donne à lutilisateur une page web à consulter Ne supporte que lencodage UTF-8 ce quon peut y mettre : - curseurs - cases à cocher - graphiques - cartes intéractives (changer le fond) - changer la langue - process automatique -&gt; vidéo - arbres décisionnaires R ne fait qu1 tache à la fois donc Shiny aussi, mais il existe des moyens de palier à ça. R -&gt; Shiny -&gt; Bootstrap -&gt; HTML/CSS/JavaScript -&gt; Navigateurs internets structurer lappli créer linterface gérer les intéractions enrichir lappli mise en ligne et partage de lappli 10.4 Structurer lappli créer un dossier ac le nom de lappli 2 fichiers : ui.R et server.R enregistrés en UTF-8 ui.R : dont fct fluidPage() (mise en forme de linterface) server.R : dont fct server &lt;- function(input, output, session) global.R (optionnel, même dossier) : chargement de variables dans envrment global de lutilisateur Il est possible de mettre ces 3 codes dans un même fichier. Lancement de lappli : bouton Run App ou shiny::runApp (dossierdes2fichiers) Appuyer sur STOP qd fini 10.5 Créer linterface ui.R et sa fct créent linterface graphique Le code R dans ui est converti en HTML (on peut aussi mettre du HTML dans ui (HTML())) sous-dossier www avec (non aacessibles sous code, uniqueùment sous ap): - image.png - style.css - script.js Formater du texte (fcts inspirée du HTML) à mettre dans fluidPage(): p() : paragraphe h1~h6() : 1er niv den-tête à 6ème niv *a(href =, target = \"_blank)* : lien hypertexte, target = \"_blank permet douvrir dans un nouvel onglet br() : retour à la ligne code() : Police code strong() : gras em() : italique img(src = image dans www) : insérer une image , à la fin de chaque ligne dans ces fonction (sépare les args) clic droit sur la page web pour en voir le code de mise ne forme en html. 10.5.1 Mise en page Page titlePanel (titre) Layout side bar panel main panel tapPanel1,2,3 Mettre des onglets : tabsetPanel() : conteneur dedans 1er onglet : tabpanel(), 2ème onglet : tabpanel(), etc Page barre latérale et panneau principal, 1/3-2/3 : sidebarLayout() (conteneur) 10.5.2 INPUTS &amp; OUPUTS Répertoriés ici: https://shiny.rstudio.com/gallery/widget-gallery.html Dans ui : INPUT + actionButton : bouton + actionLink : bouton + checkboxInput : entrée numérique + checkboxGroupInput : groupes de cases à cocher + dateInput : date avec propositions + dateRangeInput : période OUTPUT + plotOutput : graphique + imageOutput : image + tableOutput : print tableau + dataTable : tableau optimisé (interactif: affichage et recherche) + text + verbatim : format console R + html/uiOutput : ui dynamique (faire apparaitre des choses au départ caché) 10.6 Gérer les intéractions Sur ui: un identifiant (inputId =) unique par input/output et parlant label, choices seront visibles sur lapp selected : valeur selectionnée par dédaut Sur server.R : output\\(idouput &lt;- renderText(){input\\)idinput} cest lobjet calulé à la dernière ligne qui est utilisé pour mettre à jour loutpout 1 fct/output même pour un même input on peut mettre un print avant la der ligne de code pour afficher le rslt dans console un input répétitif peut être mis sous forme de fct et mis soit dans servers soit dans global. Réaction réactive : la fct reactive permet de ne pas recalculer même input à chaque output (comme un cache) (diapo 46) Chaine de réactivité : Reactive value -&gt; Reactive expression -&gt; Rendu &amp; output ou Observer input = reactive value + élmt graphique (cases, surseur etc) Reactive value avec reactiveValues(result = NULL) (voir server de calculatrice) Reactive expression = calcul lourd, extract données, mise en cache pour plsrs render/oberver. Rendu &amp; output = mise à j dun output avec un nouvel objet. Observer = gestion fine de linterface : gestion devnment (click bouton), gestion de proxy. Une expression réactive peut en observer une autre expression réactive (propagation) Fonctions : reactiveValues reactive eventReactive : réagit à un évenemnt mis en 1er argument observe observeEvent isolate pour ne pas appliquer un code sans lactivation dun code précédent (voir server calculatrice). invalidateLater : ré-exécution dun observateur/render/expr rel après un certain laps de temps debounce/throttle 10.7 Enrichir lappli 10.7.1 Leaflet cartographie (représentation spatiale) dynamique Utilise le pipe choisir le fond de carte voir code diapo ~devant les vars de data Définir le zoom initial voir code diapo ajouter des points spécifiques (markers) voir code diapo personaliser les points (description des markers) voir code diapo Ajouter des formes rayon en mètres voir code diapo Ajouter une légende voir code diapo Ajouter une échelle et la possibilité de faire des mesures voir code diapo Après un render pour initialiser, un proxy, encapsulé dans un observe, pour ne pas recalculer le fond de carte à chaque modif. Lobjet à mettre à a préalablement été construit dans un render Des proxy existent pour leaflet, DT, plotly 10.7.2 Charger/enregistrer des fichiers Il faut mettre une limite max de gigas pour protéger le serveur. 10.7.2.1 Charger Fichiers fournis par lutilisateur : input Dans ui : fileInput(inputId = fiMyFiles, multiple = TRUE,) Dans server : diapo p54 package shinyFiles pour fichiers lourds 10.7.2.2 Enregistrer Fichiers transmis à lutilisateur : output Dans ui : downloadButton(outputId = myReport,) Dans server : diapo p54 10.7.3 Shinydashboard permet de personnalisr la partie ui (rien ne change dans la partie server) Barre de navigation à gauche et une page principale pour les figures 3 parties : header, sidebar, body Dans le body, différentes boites (box) pour les différentes sorties On peut ajouter des onglets dans la sidebar, liée à la partie body Menu avec messages, notif, taches en haut à droite InfoBox, ValueBox (valeurs numériques dintérets) Personnalisation box (rétractable, ) la hauteur sadapte au contenu 10.8 Autres packages shinyjs : visibilité délmt, activité délmt, attributs déléments (couleur selon la class), code javascript shinyjs::hidden : cacher un bouton shinyWidgets : bouton switch, sliderText shinyalert : création de boite de messages personnalisée shinyhelper : ajouter de laide à une appli (description) plotly : graphiques ggplot2 intéractifs shinysccloaders : spinner (truc qui tourne) pendant le calcul shinyFeeback ou shinyvalidate : avertissement, erreur sur les valeurs saisies Tableau éditable : excelR, DataEditR, shiny-matrix Crosstalk : sélection commune et synchronysée entre plsrs outputs (pour plotly, leaflet, DT) ShinyMobile : plus adaptée à une interface téléphone, ressemble plus à une appli 10.9 Mise en ligne et partage de lappli 10.9.1 En local : cest mieux, plus rapide car outils de calcul et on y est seul à travers un package, on peut lancer son appli avec le Addins dans Rstudio ou juste dépot pour lappli sur github Application Windows sans ouvrir Rstudio, avec un R-portable (lourd) 10.9.2 A distance plsrs utilisateurs sur 1 serveur R/Shiny ShinyProxy : 1 R pour chaque utilisateur Hébergement dédié (Shinyapps.io) : offre gratuite avec des limitations 10.10 Module -&gt; Répéter des outputs pour différents onglets dans ui : création des onglets avec des données spécifiques dans server : callModule() Code du module dans dossier R (pas de sous-dossier), quil faudra sourcer fct avec code pour ui : création dID unique avec shiny::ns() fct avec code pour server 10.11 Autres sources cours mastering shiny "],["stats-à-ne-plus-chercher.html", "Cours 11 Stats à ne plus chercher 11.1 Corrélations 11.2 Evaluer la performance dune prédiction 11.3 Processus gaussiens", " Cours 11 Stats à ne plus chercher 11.1 Corrélations Une base de traits (quantitatifs) à tester : baseforcor &lt;- rootsmassMarco %&gt;% select(-var quali) pas besoin de tester la normalité si n&gt;30. CorMatrix1 &lt;- round(cor(baseforcor, use = pairwise.complete.obs), digits = 2) # matrice de corrélation, avec 2 décimales pour avoir les p-values : CorMatrixS &lt;- rcorr(as.matrix(baseforcor)) CorMatrix &lt;- CorMatrixS\\(r Pval_corr &lt;- CorMatrixS\\)P Plot de la matrice de corrélation : http://www.sthda.com/french/wiki/visualiser-une-matrice-de-correlation-par-un-correlogramme corrplot(CorMatrix, method=circle, type=lower, col=brewer.pal(n=8, name=PuOr), tl.col=black, tl.srt=45, p.mat = Pval_corr, sig.level = 0.05) #avec une croix pour les p-value &gt; 0.05. ##Inférer des données = Remplacer les NA selon les autres variables MICEinf &lt;- mice(data, maxit=100) 100 itérations, methodes par défault Visualiser les valeurs produites MICEinf\\(imp\\)varinf Mettre ces valeurs inférées dans ma base Data_completed &lt;- complete(MICEinf,5) ici jai pris la 5eme (m) estimation ##Standardizer (centrer-réduire) as.vector(scale()) 11.2 Evaluer la performance dune prédiction 11.2.1 Validation croisée (rééchantillonage) = séparer données en jeux dentraînement et de test : caret::createDataPartition() 11.3 Processus gaussiens généraliser la procédure à une quantité infinie de dimensions kernlab::gausspr() -&gt; écart-type des prédictions, donnant une appréciation de la précision du modèle "],["introduction-à-stan.html", "Cours 12 Introduction à Stan 12.1 Pourquoi les stats bayesiennes ? 12.2 Stan program :", " Cours 12 Introduction à Stan library(readr) library(tidyverse) library(rstan) rstan_options(auto_write = TRUE) #option pour ne pas recompiler à chaque fois !!! gain de temps options(mc.cores = parallel::detectCores()) #option pour ajouter des coeurs au calcul library(bayesplot) #visualiser la chaine de Markov library(shinystan) #for interactive stan output visualization library(rstanarm) #for Bayesian automatic regression modelling using stan library(brms) #Bayesian generalized multivariate non-linear multilevel models using stan 12.1 Pourquoi les stats bayesiennes ? on peut exprimer nos croyances/expertises sur les paramètres (prior) prend en compte lincertitude proprement permet de prendre tout niveau de complexité de modele Theoreme de Bayes * Prior : proba des paramètres apriori * Vraissemblance : proba des données sachant les paramètres * Posterior : distribution des paramètres sachant les données Stan = un language : - entre crochet - un point-virgule à la fin de chaque ligne - // pour commencer un commentaire - &lt;lower=0&gt; : pour borner la variable 12.2 Stan program : Ôuvrir un fichier stan. 3 blocks de commande : data block on déclare : - la taille du jeu de donnée - les differentes variables parameters block On déclare le nom des paramètres et leurs bornes si on le souhaite model block - on déclare le prior (loi que suit le paramètre) (permet daugmenter la vitesse danalyse) - sinon prior non-informatif - écriture du modèle (vraissemenblance) Les priors doivent être définis sous sens biologique/écologique GLOPNET &lt;- read_csv(&quot;GLOPNET.csv&quot;, skip=10) LES &lt;- GLOPNET %&gt;% filter(BIOME==&quot;TROP_RF&quot;, GF == &quot;T&quot;) %&gt;% select(Dataset, Species, &quot;log LL&quot;, &quot;log LMA&quot;) %&gt;% na.omit() #le bayesien ne supporte pas les NA LES %&gt;% ggplot(aes(`log LMA`, `log LL`, col=Dataset)) + geom_point() + xlab(&quot;Logarithm of Leaf Mass per Area (LMA)&quot;) + ylab(&quot;Logarythm of Leaf Lifespan (LL)&quot;) Modèle proposé : _log LL ~ N(alpha + beta *log LMA, sigma^2)_ -&gt; régression linéaire à mettre dans un fichier stan data &lt;- list( N = dim(LES) [1], #les noms des var doivent etre les memes que dans le fichier stan logLMA = LES$&quot;log LMA&quot;, logLL = LES$&quot;log LL&quot; ) fit1 &lt;- stan(&quot;stan.stan&quot;, data = data) #LET&#39;S GOOOO! Données injectées, compilation lancée ! Nombre de chaine par défaut mais on peut choisir, 4 cest le minimum pour interpréter les graphes. thin = période damaigrissement = pas de litération warmup = periode de chauffe : petite balade aléatoire lp_ = log de la vraisemblance n_eff = nbr ditérations effectives : qui sont relevantes Rhat doit être égal à 1 (ou 1.1): ça veut dire que lestimation des paramètres a réussi à converger Ici les chaînes nont pas réusi à converger, et ce sont perdues (tres peu de chaînes effectives). mcmc_trace(as.array(fit1), #as.array = comme vecteurs facet_args=list(labeller=label_parsed), #pour mettre en lettre greques np = nuts_params(fit1)) # np pour afficher la divergeance MCMC : diagnostic des chaines PPC : comparaison de modèles Il faut une exploration indépendante des paramètres pour trouver le point où ça cohabite = maximum de vraissemblance (voir dessin carnet) #les paramètres doivent être indépendants et former une patate à leur valeur correspondant aux données. mcmc_pairs(as.array(fit1)) On voit que alpha et lp_ sont liés par une relation. On voit sur les graphes des chaines, que alpha veut aller dans le négatif mais ne peut pas car défini sur R+ (loi gamma) Logique biologique : alpha doit être égal à 0 quand LMA est égal à 0 puisque sil ny a pas de masse il ny pas de feuille dont pas de duree de vie !!! Donc on vire alpha du modèle. Nouveau modele : _log LL ~ N( beta *log LMA, sigma^2)_ A mettre dans un fichier stan On peut faire une copie de lancien fichier : file &gt; coche le stan file &gt; more &gt; copy fit2 &lt;- stan(&quot;LLLMA.stan&quot;, data = data) mcmc_trace(as.array(fit2), #as.array : comme vecteurs facet_args=list(labeller=label_parsed), np = nuts_params(fit2))#pour mettre en lettre greques mcmc_pairs(as.array(fit2)) Ca fait des belles patates donc cest bon !!!! Et de beaux histos ! On veut mtn connaitre les distributions des paramètres à posteriori: on veux des paramètres : - différents de 0 (pour une relation entre var expli et var réponse) - et un sigma petit (pour un bon fit) mcmc_areas(as.array(fit2), prob=0.95, pars = c(&quot;beta&quot;, &quot;sigma&quot;)) # pars pour n&#39;afficher que les paramètres que je veux, pas la vraissemblance Posteriors sont normaux et significatifs. mcmc_intervals(as.array(fit2), prob=0.95, pars = c(&quot;beta&quot;, &quot;sigma&quot;)) #vu du dessus launch_shinystan(fit2) Conclusion : - se renseigner sur les formes de lois, de modèle - la définition des lois - centrer-réduire les variables pour faire converger plus vite (meme echelle) - borner les paramètres si possible "],["i-am-a-modeler.html", "Cours 13 I am a modeler 13.1 La modélisation 13.2 Modèle linéaire simple 13.3 Lois de probabilité de la fonction de réponse 13.4 GLM (modèles linéaires généralisés) 13.5 Modèle mixte 13.6 Créer nos prédicteurs selon leffet que lon veut tester 13.7 tests 13.8 Estimations des paramètres 13.9 Variable réponse qualitatite", " Cours 13 I am a modeler 13.1 La modélisation On récolte n observations qui sont le résultats de n expériences aléatoires indépendantes. Modélisation : on suppose que les n valeurs sont des réalisations de n variables aléatoires indépendantes et de même loi. Estimation : chercher dans le modèle une loi qui soit le plus proche possible de la loi de notre var réponse = chercher un estimateur de theta0. Validation de modèle : on revient en arrière et on tente de vérifier si lhypothèse de létape 2 est raisonnable ((normalité, linéarité, analyse des résidus, test dadéquation, etc) Modèle non-paramétrique : univers de dimension infinie Modèle paramétrique : univers de dimension finie 13.2 Modèle linéaire simple Variables quantitatives -&gt; régression Variables qualitatives -&gt; ANOVA (analyse de la variance) Variables mixtes -&gt; ANCOVA (analyse de la covariance) 13.3 Lois de probabilité de la fonction de réponse loi de probabilité = - sa fct de répartition - sa densité Différentes lois : - Variable réponse continue : Normale ou Gamma - Réponse binaire (succès-échecs, présence-absence) : Bernoulli (1 seul tirage), binomiale (plsrs tirages(nbr de succés, proportion)) Comptages (nbr entiers) : Poisson, négative binomiale, Geométrique Durée de survie : Exponentielle Choix (ladéquation du modèle aux données) : -la déviance normalisée (scaled deviance) : retenir celle qui minimise la déviance D -la statistique du khi-deux de Pearson - AIC, BIC, régression lasso Lorsque le modèle étudié est exact, la déviance normalisée D* ou le khi-deux de Pearson, suit approximativement une loi du khi-deux àn-K degrés de liberté. 13.4 GLM (modèles linéaires généralisés) Dans quel cas ? quand la variable réponse et les variables explicatives ne sont pas définis sur le même univers (intervalle de valeurs). GLM : - Modèle linéaire gaussien : Gaussienne - Régression logistique : Bernouilli (binaire), variable réponse catégorielle, ordinale ou polytomique (modalités) - Log-linéaire : Poisson Une fonction de lien spécifique (= fonction de lien canonique) permet de relier lespérance  au paramètre naturel theta (ou canonique) de la loi. En dautres mots, lier lespérance de la variable réponse () au prédicteur linéaire construit à partir des variables explicatives. Fcts de lien naturel: - Pour la loi Normale : theta =  (link=identity) - Pour la loi Poisson : theta = log() (link=log) - Pour la loi Bernouilli : theta = logit() = log(/1-) (= logarithme du rapport des chances) (link=logit) - Pour la loi Gamma : theta = 1/ (link=inverse) Fcts de liens : - Identité - Logit : est adaptée au cas où  est comprise entre 0 et1 (par exemple la probabilitéde succès dans une loi binomiale). Approbriée quand les proportions de 0 et de 1 sont équilibrées - Probit : est linverse de la fonction de répartition de la loi normale centrée réduite. Approbriée quand les proportions de 0 et de 1 sont équilibrées. - cloglog : Approbriée quand les proportions de 0 et de 1 sont trés déséquilibrées (Hardin and Hilbe (2007)) - Puissance - Logarithme - Gompit( complémentaire log log) [0;1] : logit, probit, cloglog, and loglog Sauf cas (très) particulier, le lien nest jamais parfait. La fonction de lien est inversible. Choix de la fct de lien : le choix de la fonction de lien est libre. Néanmoins choisir la fonction de lien naturel permet dassurer la convergence de lalgorithme destimation utilisé classiquement (algorithme de Newton-Raphson) vers le maximum de vraisemblance. 13.5 Modèle mixte = modèle contenant des effets fixes et des effets aléatoires. Effets fixes = effet dune variable mesurée, avec des niveaux/groupes qui sont délibérément arrangés par lexpérimentateur, donc bien définie et controlée, sur une var réponse. Effets aléatoires = effet sur la structure de léchantillon, dont les niveaux sont possibles. Dans létude de ce type deffet on ne sintéresse pas à leffet qua chacun des groupes mais à la variabilité totale quils apportent à la var réponse. 13.6 Créer nos prédicteurs selon leffet que lon veut tester interaction entre 2 variables : X3= X1*X2 (multiplication de var) effet non linéaire : X4 = X1^2 (exposant sur une variable) 13.7 tests Le test t permet de tester lhypothèse H0 pour chaque variable. Le test de Fisher permet de tester plusieurs paramètres simultanément. Le test de Fisher a plus de sens dans le cas dune ANOVA car il considère la variable explicative dans son ensemble et non modalité par modalité. 13.8 Estimations des paramètres Par minimisation des moindres carrés ou maximum de vraissemblance Résidus (epsilon) = Y - estimation dY (y chapeau) 13.9 Variable réponse qualitatite Chercher à expliquer Y par X revient à chercher de linformation sur la loi de probabilité de Y sachant X. Si on peut, rendre la variable binaire (0,1) -&gt; Bernoulli -&gt; Régression logistique "],["bayesian-stats-cours.html", "Cours 14 Bayesian stats cours 14.1 Grid approximation (to define posterior) :", " Cours 14 Bayesian stats cours design the model (data story) condition on the data (update the model) evaluate the model (critique) ex : 9 times dta : W (water) or L (land) p = proba de W proba de L = 1-p prior : information before the data (p in [0;1]) posterior : update info of each value of p conditional on data chaque postérior est le prior du prochain posterior plus on a de données plus il est aisé davoir un résulat précis Define generative relations between the variables W, L, W p * (1-p) *p = p2(1-p)1 : relative number to see W Vraissemblance : 14.1 Grid approximation (to define posterior) : posterior proba = standardizez product of proba of the data and prior proba standardisé : add up all the products and divide by this sum grid approximation uses finite grid of parameter values instead of continuous space too expensive with more yhan a few parameters Sampling from the posterior Intervals : how much mass Percentile intervals (PI): equal area in each tail Hightest posterior density intervals (HPDI) : narrowest interval containing mass Mean nearly always more sensible than the mode Model : "],["bayesian-and-stan-langage.html", "Cours 15 Bayesian and Stan langage 15.1 Règles 15.2 Les données 15.3 Definitions 15.4 Loi Poisson (positif &amp; discret) (par exemble un abondance) 15.5 Loi Bernouilli-logistique (Blogit) (réponse binaire) 15.6 Tools 15.7 Rapidité 15.8 Non-identifiabilité", " Cours 15 Bayesian and Stan langage 15.1 Règles Ne pas comparer des effets de modèles de var réponses diffentes entre eux Ne pas comparer des modèles utilisant des données différentes 15.2 Les données Toutes les variables doivent être mises sous forme numeric Regarder la distribution de nos variables pour identifier la loi quelles suivent et les transformations possibles à leur appliquer. Standardiser pour mettre toutes les variables échelles, ainsi faciliter la lecture et comparaison de leurs effets (meme dimension) : cas dun modèle explicatif. Dans le cas dun modèle prédictif on veut garder les dimensions de chaque var. Si on veut que les covarariants soient des probabilités : on les borne [0;1] Réduire la taille des données en exploratoire, et ne faire tourner lensemble des données lorsque le modèle a été validé -&gt; gain de rapidité 15.3 Definitions theta0 : cest lintercept du modèle. Cest dans certains cas lesperance predite de la var réponse, cest le témoin. A regarder pour juger de limportance des autres paramètres. Vraissemblance (totale): sum de toutes les vraissemblances particulières (=pour chaque observation). Vraissemblance totale = nbr dobs si vraissemblance parfaite du modèle. la petite montagne que forme la marche aléatoire pour trouver LA valeur de chaque paramètre priors : Non informatif par défaut : ~ \\(Gamma\\) quand modèle défini sur \\(R+\\), ~ \\(N\\) quand modèle défini sur \\(R\\) On nutilise pas les données pour définir les priors mais on peut pour borner les paramètres. Il peut être nécessaire de borner les paramètres lorsquil ny a pas deffet et que la marche aléatoire se perd. Variance (\\(\\sigma\\)) = variance de lensemble des erreurs du modèle Erreur du modèle = Var réponse/esperance du modèle 15.4 Loi Poisson (positif &amp; discret) (par exemble un abondance) Var reponse suit une loi \\(P\\) de paramètre \\(\\lambda\\) le paramètre \\(\\lambda\\) suit une loi exp dans laquelle on met les covaraints et leur paramètres pour les faire passer de \\(R\\) à \\(R+\\) nécessaire à \\(\\lambda\\) pour pouvoir comparer les paramètres les faire suivre une loi \\(N\\) Hyperlois = faire suivre une loi à un ensemble de paramètres Qd modele trés chargé en paramètres (vecteurs de parmètres) (pas 1 valeurs mais plsrs) on généralise ceux ayant leur variable associée en commun en 1 (emboités) leffet nul (theta0) na pas besoin detre emboité pour etre comparé aux autres paramètres Interet : faciliter la convergence et faire suivre le meme chemin à tout ceux qui doivent le suivre 15.5 Loi Bernouilli-logistique (Blogit) (réponse binaire) logit (=fct de lien) car il faut linéariser les facteurs 15.6 Tools Comparer prior et posterior : ppc_dens_overlay() Validation de modèle selon la capacité de prédiction : loo_compare(loo(mod1), loo(mod2)) %&gt;% kable() Il calule des différences donc le meilleur est à 0. Il faut avoir la valeur la plus haute. Dans le stan file : generated quantities { vector[I] log_lik ; ## vraisemblance pour chaque obs vector[I] prediction ; for(i in 1:I){ log_lik[i] = fct_lpmf(y[i] | theta[i]) ; ## pour loo. ##lpmf -&gt; masse de proba (cas var discrète). ...loi de densité (cas var continue) prediction[i] = fct_rng(theta[i]) ; ## pour ppc_dens_overlay(). rng -&gt; génération de } 15.7 Rapidité Réduire la taille des données 2 chaines et une 100aine ditérations Ne pas caluler certains paramètres : include = F, pars = theta largument save_warmup = F (ne pas renvoyer la période de chauffe) 15.8 Non-identifiabilité = vraisemblance reste cste malgrè changement des paramètres, incapcité à donner une valeur aux paramètres (variance trop grande) Symptomes : - chaines ne semélangent pas - corrélations des parmètres En fréquentiste pour pallier ça on implémente des contraintes. Cause : prior non informatif Solutions: centrer les variables (aide les chaînes, et enlève le prblm de corrélation entre param) tirer des paramètres de manières simultanées (par block) (Miltonien) plutot que lun après lautre (Metropolis Hastings) sum - to zero contransints : sum de la variance des random effects = 0 Raftery diagnostic : pour déterminer le nbr ditérations nécessaires reparametrisation by sweeping : ac matrice de covariance post-sweeping of random effects : on écarte les paramètres non identifiables, on ne les interprète pas. on redéfinit lintercept en prenant lintercept + variance du modèle "]]
